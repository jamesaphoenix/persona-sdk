# @jamesaphoenix/prompt-optimizer

A TypeScript package for optimizing prompts using techniques inspired by DSPy. This package provides tools for automatically improving prompts through various optimization strategies including bootstrap sampling, compositional optimization, random search, and ensemble methods.

## üéØ Features

- **Type-safe prompt optimization** with comprehensive TypeScript support
- **Multiple optimization strategies** (Bootstrap, COPRO, Random Search, Ensemble)
- **Comprehensive metrics system** for evaluating prompt performance
- **TanStack-style API** for clean, intuitive usage
- **Extensive testing** with high coverage guarantees
- **Mock implementations** for testing and development

## üì¶ Installation

```bash
npm install @jamesaphoenix/prompt-optimizer
```

## üöÄ Quick Start

```typescript
import { 
  BootstrapOptimizer, 
  ExactMatch, 
  MockModule,
  createMockLanguageModel 
} from '@jamesaphoenix/prompt-optimizer';

// Create a module to optimize
const module = new MockModule("Answer the math question: ");

// Create training data
const trainset = [
  { input: "What is 2+2?", output: "4" },
  { input: "What is 3+3?", output: "6" },
  { input: "What is 5+5?", output: "10" }
];

// Create a teacher model for bootstrapping
const teacherModel = createMockLanguageModel({
  'math': 'The answer is',
  'question': 'Let me solve this step by step'
});

// Optimize the module
const optimizer = new BootstrapOptimizer({
  maxLabeled: 5,
  maxBootstrapped: 3,
  metric: ExactMatch,
  teacherModel,
  verbose: true
});

const result = await optimizer.optimize(module, trainset);

console.log(`Optimization completed!`);
console.log(`Final score: ${result.finalScore.toFixed(3)}`);
console.log(`Rounds completed: ${result.roundsCompleted}`);
console.log(`Time taken: ${result.optimizationTimeMs}ms`);

// Use the optimized module
const optimizedPrediction = await result.optimizedModule.predict("What is 7+8?");
console.log(`Prediction: ${optimizedPrediction.output}`);
```

## üìñ Core Concepts

### Optimizers

#### Bootstrap Optimizer
Uses few-shot learning with bootstrapped examples generated by a teacher model.

```typescript
import { BootstrapOptimizer } from '@jamesaphoenix/prompt-optimizer';

const optimizer = new BootstrapOptimizer({
  maxLabeled: 10,        // Max labeled examples to use
  maxBootstrapped: 5,    // Max bootstrapped examples to generate
  bootstrapThreshold: 0.7, // Quality threshold for bootstrapped examples
  metric: ExactMatch,    // Evaluation metric
  verbose: true
});
```

#### COPRO (Compositional Prompt Optimizer)
Iteratively generates and evaluates prompt variations using an LM.

```typescript
import { COPROOptimizer } from '@jamesaphoenix/prompt-optimizer';

const optimizer = new COPROOptimizer(languageModel, {
  breadth: 10,           // Number of candidates per round
  depth: 3,              // Number of optimization rounds
  temperature: 0.7,      // Temperature for prompt generation
  numVariations: 5       // Variations to generate per candidate
});
```

#### Random Search Optimizer
Explores the optimization space through controlled randomness.

```typescript
import { RandomSearchOptimizer } from '@jamesaphoenix/prompt-optimizer';

const optimizer = new RandomSearchOptimizer({
  numCandidates: 16,     // Number of candidates to try
  budget: 100,           // Maximum evaluations
  strategy: 'mutation'   // 'mutation', 'crossover', or 'random'
});
```

#### Ensemble Optimizer
Combines multiple optimized modules for improved performance.

```typescript
import { EnsembleOptimizer } from '@jamesaphoenix/prompt-optimizer';

// Create ensemble from optimization results
const ensemble = EnsembleOptimizer.fromOptimizationResults([
  result1, result2, result3
], {
  size: 3,
  reducer: (outputs) => outputs[0], // Custom reduction function
  votingStrategy: 'hard'
});

// Use ensemble for prediction
const prediction = await ensemble.predict("Input text");
```

### Metrics

The package includes various metrics for evaluating prompt performance:

```typescript
import { 
  ExactMatch,
  FuzzyMatch, 
  PassageMatch,
  ContainsMatch,
  NumericMatch,
  createCompositeMetric 
} from '@jamesaphoenix/prompt-optimizer';

// Use built-in metrics
const exactScore = ExactMatch.evaluate(example, prediction);
const fuzzyScore = FuzzyMatch.evaluate(example, prediction);

// Create custom metrics
const customExact = createExactMatchMetric(0.8); // 80% threshold
const customFuzzy = createFuzzyMatchMetric(0.9); // 90% similarity threshold
const customNumeric = createNumericMatchMetric(0.01); // 1% tolerance

// Combine metrics
const composite = createCompositeMetric([
  { metric: ExactMatch, weight: 0.7 },
  { metric: FuzzyMatch, weight: 0.3 }
]);
```

## üß™ Testing and Mocking

The package includes comprehensive mock implementations for testing:

```typescript
import { 
  MockModule,
  MockLanguageModel,
  createMockModule,
  createTestDataset,
  measureOptimizationPerformance 
} from '@jamesaphoenix/prompt-optimizer';

// Create mock modules
const module = new MockModule('Prompt: ', ['response1', 'response2']);

// Create context-aware mock LM
const smartMock = createMockLanguageModel({
  'math': 'I can solve math problems',
  'code': 'I can help with coding',
}, 'I need more context');

// Generate test datasets
const mathDataset = createTestDataset(10, 'math');
const qaDataset = createTestDataset(5, 'qa');
const classificationDataset = createTestDataset(8, 'classification');

// Measure performance
const { result, timeMs } = await measureOptimizationPerformance(
  () => optimizer.optimize(module, trainset),
  'Optimization'
);
```

## üìä Advanced Usage

### Custom Module Implementation

```typescript
import type { Module, Prediction } from '@jamesaphoenix/prompt-optimizer';

class CustomModule implements Module {
  private prompt: string;

  constructor(prompt: string) {
    this.prompt = prompt;
  }

  async predict(input: string | Record<string, any>): Promise<Prediction> {
    // Your custom prediction logic here
    const output = await this.processInput(input);
    
    return {
      output,
      confidence: 0.9,
      metadata: {
        usage: {
          inputTokens: Math.floor(String(input).length / 4),
          outputTokens: Math.floor(output.length / 4),
          totalTokens: Math.floor((String(input).length + output.length) / 4),
        }
      }
    };
  }

  getPrompt(): string {
    return this.prompt;
  }

  setPrompt(prompt: string): void {
    this.prompt = prompt;
  }

  clone(): Module {
    return new CustomModule(this.prompt);
  }

  private async processInput(input: string | Record<string, any>): Promise<string> {
    // Your processing logic
    return "Processed: " + String(input);
  }
}
```

### Custom Metric Implementation

```typescript
import type { Metric, Example, Prediction } from '@jamesaphoenix/prompt-optimizer';

const CustomMetric: Metric = {
  name: 'custom_similarity',
  evaluate: (example: Example, prediction: Prediction): number => {
    // Your custom evaluation logic
    const expected = String(example.output);
    const actual = String(prediction.output);
    
    // Return score between 0 and 1
    return calculateSimilarity(expected, actual);
  }
};

function calculateSimilarity(a: string, b: string): number {
  // Your similarity calculation
  return a === b ? 1.0 : 0.0;
}
```

### Multi-Stage Optimization

```typescript
// Combine multiple optimization strategies
const bootstrapResult = await bootstrapOptimizer.optimize(module, trainset);
const coproResult = await coproOptimizer.optimize(
  bootstrapResult.optimizedModule, 
  trainset
);
const randomSearchResult = await randomSearchOptimizer.optimize(
  coproResult.optimizedModule,
  trainset
);

// Create ensemble from all results
const ensemble = EnsembleOptimizer.fromOptimizationResults([
  bootstrapResult,
  coproResult, 
  randomSearchResult
]);

console.log('Multi-stage optimization complete!');
```

## üîß Configuration

### Bootstrap Configuration

```typescript
interface BootstrapConfig {
  maxLabeled?: number;          // Default: 16
  maxBootstrapped?: number;     // Default: 4
  bootstrapThreshold?: number;  // Default: 0.7
  teacherModel?: LanguageModel; // Default: null
  metric?: Metric;              // Default: ExactMatch
  verbose?: boolean;            // Default: false
  maxRounds?: number;           // Default: 10
  earlyStoppingThreshold?: number; // Default: 0.95
}
```

### COPRO Configuration

```typescript
interface COPROConfig {
  breadth?: number;        // Default: 10
  depth?: number;          // Default: 3
  temperature?: number;    // Default: 0.7
  numVariations?: number;  // Default: 5
  metric?: Metric;         // Default: ExactMatch
  verbose?: boolean;       // Default: false
  maxRounds?: number;      // Default: 10
  earlyStoppingThreshold?: number; // Default: 0.95
}
```

### Random Search Configuration

```typescript
interface RandomSearchConfig {
  numCandidates?: number;  // Default: 16
  budget?: number;         // Default: 100
  strategy?: 'mutation' | 'crossover' | 'random'; // Default: 'random'
  metric?: Metric;         // Default: ExactMatch
  verbose?: boolean;       // Default: false
  maxRounds?: number;      // Default: 10
  earlyStoppingThreshold?: number; // Default: 0.95
}
```

## üìà Performance Tips

1. **Start with Bootstrap**: Use bootstrap optimization for quick improvements with labeled data
2. **Use COPRO for refinement**: Apply COPRO after bootstrap for iterative prompt refinement
3. **Leverage ensembles**: Combine multiple optimized models for better performance
4. **Choose appropriate metrics**: Select metrics that align with your task requirements
5. **Monitor token usage**: Track API costs using the built-in usage metadata
6. **Use validation sets**: Always evaluate on held-out data for unbiased performance estimates

## ü§ù Contributing

Contributions are welcome! Please read our contributing guidelines and ensure all tests pass:

```bash
# Install dependencies
pnpm install

# Run tests
pnpm test

# Run tests with coverage
pnpm test:coverage

# Build the package
pnpm build

# Type check
pnpm type-check
```

## ü§ù Contributing

This project was created entirely by [Claude Code](https://claude.ai/code). If you find a bug or want to add a feature:

1. **Submit a PR** - Create a pull request with your changes
2. **Claude Code reviews** - The AI will review your contribution
3. **Automatic merge** - Valid PRs will be reviewed and merged

We welcome all contributions!

## üìÑ License

MIT License - see LICENSE file for details.

## üôè Acknowledgments

This package is inspired by the excellent work in [DSPy](https://github.com/stanfordnlp/dspy) by Stanford NLP. We've adapted their optimization techniques for TypeScript with a focus on type safety and developer experience.